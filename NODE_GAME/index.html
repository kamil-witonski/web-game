<html>
    <head>
        <meta charset="UTF-8" />
        <title>Multiplayer Experiment</title>
        <!-- Load the Phaser game library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/2.4.2/phaser.min.js"></script>
        <!-- Load the Socket.io networking library -->
        <script src="/socket.io/socket.io.js"></script>

        <!-- Some simple styles and fonts -->
        <style type="text/css">
            body,html { /* Remove margins */
                margin: 0px;
                position: relative;
                background-color:#9FC7E1; 
            }
            canvas { /* Center the canvas */
                margin: auto;
                cursor: crosshair;
                /*border: 1px solid black;*/
            }
        </style>
    </head>
    <body>
        <script type="text/javascript">
            var ASSET_URL = "https://cdn.glitch.com/d371c629-b475-4d7b-88bc-b2558ae406a4%2F"; //Obtained from the assets folder 
            //We first initialize the phaser game object
            var WINDOW_WIDTH = 750;
            var WINDOW_HEIGHT = 500;
            var game = new Phaser.Game(50*20, 32*20, Phaser.AUTO, '', {preload:preload, create:create, update:GameLoop} );

            var WORLD_SIZE = {w:750,h:500};
          
            var groundLayer;
            var water_tiles = [];
            var bullet_array = [];
          
            var socket; //Declare it in this scope, initialize in the `create` function
            var other_players = {};
          
            var player = {
                sprite:null,//Will hold the sprite when it's created 
                speed_x:0,// This is the speed it's currently moving at
                speed_y:0,
                speed:250,
                friction:0.95,
                shot:false,
                jumpTimer: 0,
                canJump: false,
				nextFire: 0,
                createPlayer: function() {
                    this.sprite = game.add.sprite(100 ,100 ,'sprite2');
                    this.sprite.anchor.setTo(0.5,0.5);

                    // this.sprite.body.setSize()

                    //enable physics
                    game.physics.enable(this.sprite, Phaser.Physics.ARCADE);

                    this.sprite.body.collideWorldBounds = true;
                },
                update: function(){

                    //set up colision between player and ground layers
                    game.physics.arcade.collide(this.sprite, groundLayer);
                    //game.physics.arcade.overlap(this.sprite, groundLayer, function(){}, null, this);

                    this.speed_x = 0;
                    this.speed_y = 0;

                    this.sprite.body.velocity.x = 0;

                    // handle jump
                    if(game.input.keyboard.isDown(Phaser.Keyboard.W) || game.input.keyboard.isDown(Phaser.Keyboard.UP)) {
                        this.jumpTimer += game.time.elapsed;

                        //check if we are on the ground and jump initially
                        if(this.sprite.body.blocked.down) {
                            this.canJump = true;

                            this.sprite.body.velocity.y = -250;
                            
                        }

                        //if we can jump and the key has been held 
                        if (this.canJump && this.jumpTimer !== 0) {

                            //check how long its been held for
                            if(this.jumpTimer > 300) {
                                this.canJump = false;
                                this.jumpTimer = 0;
                            }

                            //add extra jump for higher jumps
                            this.sprite.body.velocity.y = -350;
                        }
                        //reset everything when we let of the key
                    } else {
                        this.canJump = false;
                        this.jumpTimer = 0;
                    }

                    if(game.input.keyboard.isDown(Phaser.Keyboard.A) || game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
                        this.speed_x -= this.speed;
                    }

                    if(game.input.keyboard.isDown(Phaser.Keyboard.D) || game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
                        this.speed_x += this.speed;
                    }
					
					if(game.input.activePointer.isDown) {
						console.log("bullet");
						this.fireWeapon();
					}

                    //move the actual sprite
                    this.sprite.body.velocity.x = this.speed_x;
                 
                    // Tell the server we've moved 
                    socket.emit('move-player',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation});


                    game.debug.body(this.sprite);
                    game.debug.bodyInfo(this.sprite);
                },
				fireWeapon: function( ) {
					if(game.time.now > this.nextFire) {								
						var fireRate = 200;

						//claculate the next time you can fire weapon
						this.nextFire = game.time.now + fireRate;

						//if all the bullets form the magazine have been used prevent from shooting while reloading
						if(this.bulletsFired >= 6) {
							this.nextFire = game.time.now + 20;

							//play reload sound
							this.bulletsFired = 0;
							return;
						}

						//get the simple bullet implementation going
						var mousePoint = {x: game.input.mousePointer.x, y: game.input.mousePointer.y};
						//figure out the angle from the sprite to the mouse pointer
						var angleToPointer = game.physics.arcade.angleToPointer(this.sprite);
						
						//
						var vel = game.physics.arcade.velocityFromRotation(angleToPointer);
							
						console.log(vel);
						console.log(angleToPointer);  
						
						socket.emit('shoot-bullet', {x: this.sprite.x, y: this.sprite.y, speed_x: vel.x , speed_y:vel.y });
					}
				}
            };

            function CreateLocalPlayer(x,y,angle){
                var sprite = game.add.sprite(x,y,'sprite1');
                sprite.rotation = angle;
                sprite.anchor.setTo(0.5,0.5);
                return sprite;
            }


            function preload(){
                game.load.tilemap('john', '/public/assets/map/john.json', null, Phaser.Tilemap.TILED_JSON);
                game.load.spritesheet('tileset', '/public/assets/map/5z1KX.png',32,32);
                game.load.image('sprite','/public/assets/sprites/sprite.png'); // this will be the sprite of the players


                game.load.image('sprite1','/public/assets/sprites/sprite1.png');
                game.load.image('sprite2','/public/assets/sprites/sprite2.png');

                this.load.image('bullet', '/public/assets/sprites/bullet.png');
            }

            function create(){

                //initialise the maps
                var map = game.add.tilemap('john');
                map.addTilesetImage('tileset'); // tilesheet is the key of the tileset in map's JSON file

                //layer 0 is always the colision layer !!!
                groundLayer = map.createLayer(0);

                //create all the layers attached to the tile map
                var layer;
                // for(var i = 1; i < map.layers.length; i++) {
                //     layer = map.createLayer(i);
                //     layer.resizeWorld();
                // }
                
                groundLayer.resizeWorld();

                game.physics.enable(groundLayer, Phaser.Physics.ARCADE);
                groundLayer.body.immovable = true;


                game.stage.disableVisibilityChange = true;
                game.physics.arcade.gravity.y = 500;
               
                map.setCollisionByExclusion([], true, groundLayer);

                player.createPlayer();

                //make the agem camera follow the player
                game.camera.x = player.sprite.x - WINDOW_WIDTH/2;
                game.camera.y = player.sprite.y - WINDOW_HEIGHT/2;


                //create multiplayer link
                socket = io(); // This triggers the 'connection' event on the server
                socket.emit('new-player',{x:player.sprite.x,y:player.sprite.y,angle:player.sprite.rotation,type:1})

                // Listen for other players connecting
                socket.on('update-players',function(players_data){
                    var players_found = {};
                    // Loop over all the player data received
                    for(var id in players_data){
                        // If the player hasn't been created yet
                        if(other_players[id] == undefined && id != socket.id){ // Make sure you don't create yourself
                            var data = players_data[id];
                            var p = CreateLocalPlayer(data.x,data.y,data.angle);
                            other_players[id] = p;
                            console.log("Created new player at (" + data.x + ", " + data.y + ")");
                        }
                        players_found[id] = true;
                        
                        // Update positions of other players 
                        if(id != socket.id){
                          other_players[id].target_x  = players_data[id].x; // Update target, not actual position, so we can interpolate
                          other_players[id].target_y  = players_data[id].y;
                          other_players[id].target_rotation  = players_data[id].angle;
                        }
                        
                        
                    }
                    // Check if a player is missing and delete them 
                    for(var id in other_players){
                        if(!players_found[id]){
                            other_players[id].destroy();
                            delete other_players[id];
                        }
                    }
                   
                })
              
                // Listen for bullet update events 
                socket.on('bullets-update',function(server_bullet_array){
				
                  // If there's not enough bullets on the client, create them
                 for(var i=0;i<server_bullet_array.length;i++){
                      if(bullet_array[i] == undefined){
                          bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet');
                      } else {
                          //Otherwise, just update it! 
                          bullet_array[i].x = server_bullet_array[i].x; 
                          bullet_array[i].y = server_bullet_array[i].y;
                      }
                  }
                  // Otherwise if there's too many, delete the extra 
                  for(var i=server_bullet_array.length;i<bullet_array.length;i++){
                       bullet_array[i].destroy();
                       bullet_array.splice(i,1);
                       i--;
                   }
                  
                })
              
                // Listen for any player hit events and make that player flash 
                socket.on('player-hit',function(id){
                    if(id == socket.id){
                        //If this is you
                        player.sprite.alpha = 0;
                    } else {
                        // Find the right player 
                        other_players[id].alpha = 0;
                    }
                })

            }
			
			
			
			
			
			
			
			

            function GameLoop(){
                player.update();

                // Move camera with player 
                var camera_x = player.sprite.x - WINDOW_WIDTH/2;
                var camera_y = player.sprite.y - WINDOW_HEIGHT/2;
                game.camera.x += (camera_x - game.camera.x) * 0.08;
                game.camera.y += (camera_y - game.camera.y) * 0.08;
              
                // Each player is responsible for bringing their alpha back up on their own client 
                // Make sure other players flash back to alpha = 1 when they're hit 
                for(var id in other_players){
                    if(other_players[id].alpha < 1){
                        other_players[id].alpha += (1 - other_players[id].alpha) * 0.16;
                    } else {
                        other_players[id].alpha = 1;
                    }
                }
              
                // Interpolate all players to where they should be 
                for(var id in other_players){
                    var p = other_players[id];
                    if(p.target_x != undefined){
                        p.x += (p.target_x - p.x) * 0.16;
                        p.y += (p.target_y - p.y) * 0.16;
                        // Intepolate angle while avoiding the positive/negative issue 
                        var angle = p.target_rotation;
                        var dir = (angle - p.rotation) / (Math.PI * 2);
                        dir -= Math.round(dir);
                        dir = dir * Math.PI * 2;
                        p.rotation += dir * 0.16;
                    }
                }

            }
          
            

        </script>

    </body>
</html>
